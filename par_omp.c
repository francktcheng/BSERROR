#include <stdio.h>
#include <math.h>
#include <mkl.h>
#include <mkl_vsl.h>
#include <omp.h>
#include "inc/misc.h"

#define real double
#define ALIGNED __attribute__((aligned(64)))
#define N 100000
#define Ncache 5200 //tunable
//suggested Ncache 1301333 for L2
//81333 for L1
#define GUIDED_CHUNK 1 //tunable

real NRV[Ncache] ALIGNED; // normal distribution random vector
real BM[Ncache] ALIGNED; // brownian motion
real PX[Ncache+1] ALIGNED; // price  

const real PI = 3.14159265358979323846; /* pi */
const real X0 = 10; //price of risky asset at t0
const real SIGMA = 0.5; //volatility of risky asset
const real K = 12; //strike price of the option
const real T = 1.0; //muaturity time 
const unsigned long long M = 1; //Monte Carlo Simulation
//const real EPSILON = X0*1.0E-2; //threshold value
const real prob = 0.95;

real NormalIntegral(real b);

int main(int argc, char *argv[])
{
  unsigned long long count = 0;
  real EPSILON = X0*1.0E-2;
  real err;
  const real dt = T/N;
  const real rootdt = sqrt((real)T/N);
  int nCal = N/Ncache;
  const int left = N%Ncache;
  VSLStreamStatePtr stream; 
  int errcode = vslNewStream(&stream, VSL_BRNG_MT2203, 0);//seed=0

  start_timer();
  for (unsigned long long m = 0; m < M; ++m){
    // one-time MC simulation
    err = 0.0;
    vdRngGaussian(VSL_RNG_METHOD_GAUSSIAN_BOXMULLER, stream, Ncache, NRV, 0.0f, 1.0f);// leaves the rest of random numbers generated by the idle thread
    BM[0] = rootdt*NRV[0];
    PX[0] = X0;
    for (int k = 0; k < nCal; ++k){
      //rootdt:firstprivate???
#pragma omp parallel default(none) shared(NRV, BM, PX, stream, err, rootdt, dt, k)
      {
	real errloc = 0.0;
	real upbd, tmp;
	//GUIDED_CHUNK too large: load imbalance
	//GUIDED_CHUNK too small: scheduling overhead
	//#pragma omp for schedule(guided, GUIDED_CHUNK)
#pragma omp for schedule(guided) //tunable 
	for (int i = 1; i < Ncache; ++i){
	  tmp = BM[0]; 
#pragma simd reduction(+:tmp) vectorlengthfor(real) assert
	  for (int j = 1; j <= i; ++j){
	    tmp += rootdt*NRV[j];
	  }
	  BM[i] = tmp;
	  PX[i+1] = X0*exp(-0.5*SIGMA*SIGMA*(k*Ncache+i+1)*dt+SIGMA*tmp);
	}
#pragma omp single
	{
	  PX[1] = X0*exp(-0.5*SIGMA*SIGMA*(k*Ncache+1)*dt+SIGMA*BM[0]);
	}
	
	//maybe vary the scheduling strategy?
#pragma omp for reduction(+:err) nowait
	for (int i = 0; i < Ncache; ++i){
	  int j = k*Ncache+i;
	  real Tj = j*(real)T/N;
	  upbd = (log(PX[i]/K)+0.5*SIGMA*SIGMA*(T-Tj))/(SIGMA*sqrt(T-Tj));
	  //errloc -= 1/(sqrt(2*PI))*(PX[i+1]-PX[i])*NormalIntegral(upbd);
	  err += -1/(sqrt(2*PI))*(PX[i+1]-PX[i])*NormalIntegral(upbd);
	}

#pragma omp single 
	{
	  vdRngGaussian(VSL_RNG_METHOD_GAUSSIAN_BOXMULLER, stream, Ncache, NRV, 0.0f, 1.0f);// leaves the rest of random numbers generated by the idle thread
	}//single
      }//parallel
      BM[0] = BM[Ncache-1] + rootdt*NRV[0];
      PX[0] = PX[Ncache];
    }//for nCal 

#pragma omp parallel default(none) shared(NRV, BM, PX, err, rootdt, dt, nCal, left)
    {
      real errloc = 0.0;
      real upbd, tmp;
      //GUIDED_CHUNK too large: load imbalance
      //GUIDED_CHUNK too small: scheduling overhead
      //#pragma omp for schedule(guided, GUIDED_CHUNK)
#pragma omp for schedule(guided) //tunable
      for (int i = 1; i < left; ++i){
	tmp = BM[0];
#pragma simd reduction(+:tmp) vectorlengthfor(real) assert
	for (int j = 1; j <= i; ++j){
	  tmp += rootdt*NRV[j];
	}
	BM[i] = tmp;
	PX[i+1] = X0*exp(-0.5*SIGMA*SIGMA*(nCal*Ncache+i+1)*dt+SIGMA*BM[i]);
      }
#pragma omp single
      {
	PX[1] = X0*exp(-0.5*SIGMA*SIGMA*(nCal*Ncache+1)*dt+SIGMA*BM[0]);
      }
      
      //maybe vary the scheduling strategy?
#pragma omp for reduction(+:err)
      for (int i = 0; i < left; ++i){
	int j = nCal*Ncache+i;
	real Tj = j*(real)T/N;
	upbd = (log(PX[i]/K)+0.5*SIGMA*SIGMA*(T-Tj))/(SIGMA*sqrt(T-Tj));
	err += -1/sqrt((2*PI))*(PX[i+1]-PX[i])*NormalIntegral(upbd);
      }

#pragma omp sections 
      {
#pragma omp section
	{
	  upbd = (log(X0/K) + 0.5*SIGMA*SIGMA*T)/(SIGMA*sqrt(T));
	  errloc -= X0/(sqrt(2*PI))*NormalIntegral(upbd);
#pragma omp atomic
	  err += errloc;
	}
#pragma omp section
	{
	  upbd = (log(X0/K) - 0.5*SIGMA*SIGMA*T)/(SIGMA*sqrt(T));
	  errloc += K/(sqrt(2*PI))*NormalIntegral(upbd);
#pragma omp atomic
	  err += errloc;
	}
#pragma omp section
	{
	  if(PX[left] > K){
	    errloc += PX[left] - K;
#pragma omp atomic
	    err += errloc;
	  }
	}
      }//sections
    }//parallel

    err = fabs(err);
    if(err < EPSILON)
      count++;
  }
  printf ("time %g ms\n", stop_timer());
  
  printf("err=%.10lf\n",err);
  
  printf("count=%llu, M=%llu\n", count, M);
  printf("%.5g\n", (real)count/(real)M);

  return 0;
}

real NormalIntegral(real b)
{
  //if(b < -10.0) return  0.0f;
  //if(b > 10.0) return 1.0f;
  const int NN = 10000;
  real a = 0.0f;
  real s, h, sum = 0.0f;
  h = (b-a)/NN;
  // add in the first few terms 
  sum += exp(-a*a/2.0) + 4.0*exp(-(a+h)*(a+h)/2.0);
  // and the last one
  sum += exp(-b*b/2.0);

#pragma simd reduction(+:sum) vectorlengthfor(real) assert
  for (int i = 1; i < NN/2; ++i){
    s = a + 2*i*h;
    sum += 2.0*exp(-s*s/2.0);
    s += h;
    sum += 4.0*exp(-s*s/2.0);
  }
  
  sum = 0.5*sqrt(2*PI) + h*sum/3.0;
  return sum;
}
