\relax 
\providecommand\HyperFirstAtBeginDocument{\AtBeginDocument}
\HyperFirstAtBeginDocument{\ifx\hyper@anchor\@undefined
\global\let\oldcontentsline\contentsline
\gdef\contentsline#1#2#3#4{\oldcontentsline{#1}{#2}{#3}}
\global\let\oldnewlabel\newlabel
\gdef\newlabel#1#2{\newlabelxx{#1}#2}
\gdef\newlabelxx#1#2#3#4#5#6{\oldnewlabel{#1}{{#2}{#3}}}
\AtEndDocument{\ifx\hyper@anchor\@undefined
\let\contentsline\oldcontentsline
\let\newlabel\oldnewlabel
\fi}
\fi}
\global\let\hyper@last\relax 
\gdef\HyperFirstAtBeginDocument#1{#1}
\providecommand*\HyPL@Entry[1]{}
\HyPL@Entry{0<</P(1)>>}
\HyPL@Entry{1<</P(1)>>}
\HyPL@Entry{2<</P(1)>>}
\@writefile{toc}{\contentsline {chapter}{\numberline {1}背景综述}{1}{chapter.1}}
\@writefile{lof}{\addvspace {10\p@ }}
\@writefile{lot}{\addvspace {10\p@ }}
\@writefile{toc}{\contentsline {section}{\numberline {1.1}高性能计算的诞生和发展}{1}{section.1.1}}
\newlabel{sec:intro-hpc}{{1.1}{1}{高性能计算的诞生和发展\relax }{section.1.1}{}}
\HyPL@Entry{3<</P(2)>>}
\@writefile{lof}{\contentsline {figure}{\numberline {1.1}{\ignorespaces Intel处理器的发展趋势}}{2}{figure.1.1}}
\newlabel{fig:intelProcessor}{{1.1}{2}{Intel处理器的发展趋势\relax }{figure.1.1}{}}
\HyPL@Entry{4<</P(3)>>}
\@writefile{lof}{\contentsline {figure}{\numberline {1.2}{\ignorespaces Top500超算集群的性能发展}}{3}{figure.1.2}}
\newlabel{fig:top500Perf}{{1.2}{3}{Top500超算集群的性能发展\relax }{figure.1.2}{}}
\HyPL@Entry{5<</P(4)>>}
\@writefile{toc}{\contentsline {section}{\numberline {1.2}金融领域的超算应用}{4}{section.1.2}}
\newlabel{sec:intro-finance}{{1.2}{4}{金融领域的超算应用\relax }{section.1.2}{}}
\HyPL@Entry{6<</P(5)>>}
\citation{WhenIsTimeContinuous}
\citation{DiscreteTimeHedgingErrors}
\citation{Hayashi05evaluatinghedging}
\HyPL@Entry{7<</P(6)>>}
\@writefile{toc}{\contentsline {chapter}{\numberline {2}课题陈述}{6}{chapter.2}}
\@writefile{lof}{\addvspace {10\p@ }}
\@writefile{lot}{\addvspace {10\p@ }}
\newlabel{chp:2}{{2}{6}{课题陈述\relax }{chapter.2}{}}
\@writefile{toc}{\contentsline {section}{\numberline {2.1}欧式期权}{6}{section.2.1}}
\newlabel{sec:euroOption}{{2.1}{6}{欧式期权\relax }{section.2.1}{}}
\@writefile{toc}{\contentsline {section}{\numberline {2.2}Black-Scholes模型}{6}{section.2.2}}
\newlabel{sec:BlackScholes}{{2.2}{6}{Black-Scholes模型\relax }{section.2.2}{}}
\HyPL@Entry{8<</P(7)>>}
\@writefile{toc}{\contentsline {section}{\numberline {2.3}课题表述}{7}{section.2.3}}
\newlabel{sec:subject}{{2.3}{7}{课题表述\relax }{section.2.3}{}}
\citation{ContinuousMartingaleAndBrownianMotion}
\citation{rootzen1980}
\HyPL@Entry{9<</P(8)>>}
\HyPL@Entry{10<</P(9)>>}
\@writefile{lop}{\contentsline {algorithm}{\numberline {1}{\ignorespaces 欧式期权对冲策略误差判断的串行算法}}{9}{algorithm.1}}
\newlabel{alg:bserror}{{1}{9}{课题表述\relax }{algorithm.1}{}}
\citation{MouvementBrownien}
\citation{LPEstimates}
\citation{SingularIntegrals}
\HyPL@Entry{11<</P(10)>>}
\@writefile{toc}{\contentsline {chapter}{\numberline {3}参数选择及收敛条件}{10}{chapter.3}}
\@writefile{lof}{\addvspace {10\p@ }}
\@writefile{lot}{\addvspace {10\p@ }}
\newlabel{chp:3}{{3}{10}{参数选择及收敛条件\relax }{chapter.3}{}}
\@writefile{toc}{\contentsline {section}{\numberline {3.1}参数优化}{10}{section.3.1}}
\newlabel{sec:N}{{3.1}{10}{参数优化\relax }{section.3.1}{}}
\@writefile{thm}{\contentsline {lemma}{{\hspace {2em}引理}{3.1.{1}}{}}{10}{lemma.1}}
\@writefile{thm}{\contentsline {lemma}{{\hspace {2em}引理}{3.1.{2}}{}}{10}{lemma.2}}
\HyPL@Entry{12<</P(11)>>}
\HyPL@Entry{13<</P(12)>>}
\HyPL@Entry{14<</P(13)>>}
\@writefile{thm}{\contentsline {theorem}{{\hspace {2em}定理}{3.1.{1}}{}}{13}{theorem.3.1.1}}
\HyPL@Entry{15<</P(14)>>}
\@writefile{toc}{\contentsline {section}{\numberline {3.2}迭代算法}{14}{section.3.2}}
\newlabel{sec:M}{{3.2}{14}{迭代算法\relax }{section.3.2}{}}
\HyPL@Entry{16<</P(15)>>}
\@writefile{toc}{\contentsline {chapter}{\numberline {4}并行化算法}{15}{chapter.4}}
\@writefile{lof}{\addvspace {10\p@ }}
\@writefile{lot}{\addvspace {10\p@ }}
\newlabel{chp:4}{{4}{15}{并行化算法\relax }{chapter.4}{}}
\@writefile{toc}{\contentsline {section}{\numberline {4.1}并行性分析}{15}{section.4.1}}
\newlabel{sec:parallelism}{{4.1}{15}{并行性分析\relax }{section.4.1}{}}
\HyPL@Entry{17<</P(16)>>}
\@writefile{toc}{\contentsline {section}{\numberline {4.2}单机并行算法}{16}{section.4.2}}
\newlabel{sec:monoparallel}{{4.2}{16}{单机并行算法\relax }{section.4.2}{}}
\newlabel{alg:omp1}{{4.2}{16}{单机并行算法\relax }{section.4.2}{}}
\newlabel{alg:omp2_1}{{4.2}{16}{单机并行算法\relax }{section.4.2}{}}
\newlabel{alg:omp2_2}{{4.2}{16}{单机并行算法\relax }{section.4.2}{}}
\@writefile{toc}{\contentsline {subsection}{\numberline {4.2.1}方案一}{16}{subsection.4.2.1}}
\HyPL@Entry{18<</P(17)>>}
\@writefile{lop}{\contentsline {algorithm}{\numberline {2}{\ignorespaces 基于多线程（multithreading）和矢量化（vectorization）的单机并行算法一(单次蒙特卡洛模拟)}}{17}{algorithm.2}}
\newlabel{alg:omp1}{{2}{17}{方案一\relax }{algorithm.2}{}}
\HyPL@Entry{19<</P(18)>>}
\@writefile{toc}{\contentsline {subsection}{\numberline {4.2.2}方案二}{18}{subsection.4.2.2}}
\newlabel{alg:omp1}{{4.2.2}{18}{方案二\relax }{algorithm.3}{}}
\@writefile{toc}{\contentsline {section}{\numberline {4.3}矢量化积分运算}{18}{section.4.3}}
\newlabel{sec:vecintegral}{{4.3}{18}{矢量化积分运算\relax }{section.4.3}{}}
\newlabel{eq:simpson}{{4.2}{18}{矢量化积分运算\relax }{equation.4.3.2}{}}
\newlabel{eq:gauss}{{4.3}{18}{矢量化积分运算\relax }{equation.4.3.3}{}}
\@writefile{toc}{\contentsline {section}{\numberline {4.4}N的最优化搜索}{18}{section.4.4}}
\newlabel{sec:searchN}{{4.4}{18}{N的最优化搜索\relax }{section.4.4}{}}
\HyPL@Entry{20<</P(19)>>}
\@writefile{lop}{\contentsline {algorithm}{\numberline {3}{\ignorespaces 基于多线程（multithreading）和矢量化（vectorization）的单机并行算法二(单次蒙特卡洛模拟)，第一部分}}{19}{algorithm.3}}
\newlabel{alg:omp2_1}{{3}{19}{方案二\relax }{algorithm.3}{}}
\HyPL@Entry{21<</P(20)>>}
\@writefile{lop}{\contentsline {algorithm}{\numberline {4}{\ignorespaces 基于多线程（multithreading）和矢量化（vectorization）的单机并行算法二(单次蒙特卡洛模拟)，第二部分}}{20}{algorithm.4}}
\newlabel{alg:omp2_2}{{4}{20}{方案二\relax }{algorithm.4}{}}
\@writefile{lop}{\contentsline {algorithm}{\numberline {5}{\ignorespaces 基于Simpson公式的高斯积分串行算法}}{20}{algorithm.5}}
\newlabel{alg:simpson_ser}{{5}{20}{矢量化积分运算\relax }{algorithm.5}{}}
\HyPL@Entry{22<</P(21)>>}
\@writefile{lop}{\contentsline {algorithm}{\numberline {6}{\ignorespaces 基于Simpson公式的高斯积分矢量化算法}}{21}{algorithm.6}}
\newlabel{alg:simpson_par}{{6}{21}{矢量化积分运算\relax }{algorithm.6}{}}
\HyPL@Entry{23<</P(22)>>}
\@writefile{lop}{\contentsline {algorithm}{\numberline {7}{\ignorespaces 最优$N$值的搜索算法}}{22}{algorithm.7}}
\newlabel{alg:searchN}{{7}{22}{N的最优化搜索\relax }{algorithm.7}{}}
\@writefile{toc}{\contentsline {section}{\numberline {4.5}多机并行}{22}{section.4.5}}
\newlabel{sec:mpi}{{4.5}{22}{多机并行\relax }{section.4.5}{}}
\HyPL@Entry{24<</P(23)>>}
\HyPL@Entry{25<</P(24)>>}
\@writefile{lop}{\contentsline {algorithm}{\numberline {8}{\ignorespaces 基于MPI的多机并行算法，boss部分}}{24}{algorithm.8}}
\newlabel{alg:mpi}{{8}{24}{多机并行\relax }{algorithm.8}{}}
\HyPL@Entry{26<</P(25)>>}
\@writefile{lop}{\contentsline {algorithm}{\numberline {9}{\ignorespaces 基于MPI的多机并行算法，worker部分}}{25}{algorithm.9}}
\newlabel{alg:mpi}{{9}{25}{多机并行\relax }{algorithm.9}{}}
\HyPL@Entry{27<</P(26)>>}
\@writefile{toc}{\contentsline {chapter}{\numberline {5}模型验证及实验结果分析}{26}{chapter.5}}
\@writefile{lof}{\addvspace {10\p@ }}
\@writefile{lot}{\addvspace {10\p@ }}
\newlabel{chap:exp}{{5}{26}{模型验证及实验结果分析\relax }{chapter.5}{}}
\@writefile{toc}{\contentsline {section}{\numberline {5.1}单块Xeon Phi和CPU的实验对比}{26}{section.5.1}}
\newlabel{sec:singleMIC-CPU}{{5.1}{26}{单块Xeon Phi和CPU的实验对比\relax }{section.5.1}{}}
\@writefile{toc}{\contentsline {subsection}{\numberline {5.1.1}单机并行方案一的实验}{26}{subsection.5.1.1}}
\newlabel{sub:bsV1}{{5.1.1}{26}{单机并行方案一的实验\relax }{subsection.5.1.1}{}}
\@writefile{toc}{\contentsline {subsection}{\numberline {5.1.2}单机并行方案二的实验}{26}{subsection.5.1.2}}
\newlabel{sub:bsV2}{{5.1.2}{26}{单机并行方案二的实验\relax }{subsection.5.1.2}{}}
\newlabel{fig:v2-Nvec}{{5.1.2}{26}{单机并行方案二的实验\relax }{subsection.5.1.2}{}}
\HyPL@Entry{28<</P(27)>>}
\@writefile{lof}{\contentsline {figure}{\numberline {5.1}{\ignorespaces 算法Omp1在不同Ncache值下的运行时间, $N=10^6$, $M=10$, 图中Omp1的运行时间随着Ncache的值先降低后增加，表明Ncache有一个 最佳的取值范围。图中也可以看出同样地参数下算法在Xeon Phi平台上表现得比CPU平台下更好。由于M的取值较小，曲线具有一定的波动性。}}{27}{figure.5.1}}
\newlabel{fig:v1-Ncache}{{5.1}{27}{算法Omp1在不同Ncache值下的运行时间, $N=10^6$, $M=10$, 图中Omp1的运行时间随着Ncache的值先降低后增加，表明Ncache有一个 最佳的取值范围。图中也可以看出同样地参数下算法在Xeon Phi平台上表现得比CPU平台下更好。由于M的取值较小，曲线具有一定的波动性。\relax }{figure.5.1}{}}
\@writefile{toc}{\contentsline {subsection}{\numberline {5.1.3}两种单机并行方案的对比}{27}{subsection.5.1.3}}
\newlabel{sub:compareV1V2}{{5.1.3}{27}{两种单机并行方案的对比\relax }{subsection.5.1.3}{}}
\newlabel{fig:compareV1V2}{{5.1.3}{27}{两种单机并行方案的对比\relax }{subsection.5.1.3}{}}
\HyPL@Entry{29<</P(28)>>}
\@writefile{lof}{\contentsline {figure}{\numberline {5.2}{\ignorespaces 算法Omp1在MIC以及不同Chunk值下的时间, $N=10^5$, $M=10$, 图中当Ncache小于$10^4$时，各种Chunk值对应的曲线都有随机波动，但是 并没有明显的优劣之分，而当$Ncache > 10^4$时，不同Chunk值的曲线都收敛在一起。}}{28}{figure.5.2}}
\newlabel{fig:v1-mic-chunck-Ncache}{{5.2}{28}{算法Omp1在MIC以及不同Chunk值下的时间, $N=10^5$, $M=10$, 图中当Ncache小于$10^4$时，各种Chunk值对应的曲线都有随机波动，但是 并没有明显的优劣之分，而当$Ncache > 10^4$时，不同Chunk值的曲线都收敛在一起。\relax }{figure.5.2}{}}
\@writefile{toc}{\contentsline {section}{\numberline {5.2}多块Xeon Phi的并行结果分析}{28}{section.5.2}}
\newlabel{sec:multiMIC}{{5.2}{28}{多块Xeon Phi的并行结果分析\relax }{section.5.2}{}}
\@writefile{toc}{\contentsline {section}{\numberline {5.3}算法的收敛性研究}{28}{section.5.3}}
\newlabel{sec:converge}{{5.3}{28}{算法的收敛性研究\relax }{section.5.3}{}}
\bibstyle{plain}
\@input{bu.aux}
\bibdata{docear}
\HyPL@Entry{30<</P(29)>>}
\@writefile{lof}{\contentsline {figure}{\numberline {5.3}{\ignorespaces 算法Omp1在CPU以及不同Chunk值下运行时间对比, $N=10^5$, $M=10$, 图中的曲线出现较大的波动性，不同的Chunk值对应的曲线之间 也没有明显的优劣，但所有的曲线都有一个明显的总体趋势，即有一个Ncache的最佳取值范围获得最好的性能}}{29}{figure.5.3}}
\newlabel{fig:v1-cpu-chunck-Ncache}{{5.3}{29}{算法Omp1在CPU以及不同Chunk值下运行时间对比, $N=10^5$, $M=10$, 图中的曲线出现较大的波动性，不同的Chunk值对应的曲线之间 也没有明显的优劣，但所有的曲线都有一个明显的总体趋势，即有一个Ncache的最佳取值范围获得最好的性能\relax }{figure.5.3}{}}
\HyPL@Entry{31<</P(30)>>}
\@writefile{lof}{\contentsline {figure}{\numberline {5.4}{\ignorespaces 算法Omp2在不同Nvec值下的运行时间, $N=10^6$, $M=10$, CPU所代表的红色曲线波动性较小，随着Nvec的值也无明显变化，说明系统在默认的 Chunk策略下自动进行了调整；同样Xeon Phi所代表的蓝色曲线虽然比红色曲线波动更大，但是总体趋势也是稳定在一个较优的性能上。}}{30}{figure.5.4}}
\newlabel{fig:v2-Nvec}{{5.4}{30}{算法Omp2在不同Nvec值下的运行时间, $N=10^6$, $M=10$, CPU所代表的红色曲线波动性较小，随着Nvec的值也无明显变化，说明系统在默认的 Chunk策略下自动进行了调整；同样Xeon Phi所代表的蓝色曲线虽然比红色曲线波动更大，但是总体趋势也是稳定在一个较优的性能上。\relax }{figure.5.4}{}}
\HyPL@Entry{32<</P(31)>>}
\@writefile{lof}{\contentsline {figure}{\numberline {5.5}{\ignorespaces 算法Omp2在MIC以及不同Chunk值下的时间, $N=10^5$, $M=10$, 可以明显地看到不同的曲线在Nvec的值大于100后出现了分离，较小值的Chunk策略 获得了更好地性能，这是由于较小的单个线程任务量减弱了Nvec值超出单个核缓存造成的性能降低;而当Nvec的取值较小时不同的Chunk取值无明显区别。}}{31}{figure.5.5}}
\newlabel{fig:v2-mic-chunck-Nvec}{{5.5}{31}{算法Omp2在MIC以及不同Chunk值下的时间, $N=10^5$, $M=10$, 可以明显地看到不同的曲线在Nvec的值大于100后出现了分离，较小值的Chunk策略 获得了更好地性能，这是由于较小的单个线程任务量减弱了Nvec值超出单个核缓存造成的性能降低;而当Nvec的取值较小时不同的Chunk取值无明显区别。\relax }{figure.5.5}{}}
\HyPL@Entry{33<</P(32)>>}
\@writefile{lof}{\contentsline {figure}{\numberline {5.6}{\ignorespaces 算法Omp2在CPU以及不同Chunk值下运行时间对比, $N=10^5$, $M=10$}}{32}{figure.5.6}}
\newlabel{fig:v2-cpu-chunck-Nvec}{{5.6}{32}{算法Omp2在CPU以及不同Chunk值下运行时间对比, $N=10^5$, $M=10$\relax }{figure.5.6}{}}
\HyPL@Entry{34<</P(33)>>}
\@writefile{lof}{\contentsline {figure}{\numberline {5.7}{\ignorespaces Omp1, Omp2相对串行算法在MIC上的加速对比, Chunk 采用系统默认模式, $N=251988$, $M=100$, $Ncache=2000$, $Nvec=376$}}{33}{figure.5.7}}
\newlabel{fig:compareV1V2}{{5.7}{33}{Omp1, Omp2相对串行算法在MIC上的加速对比, Chunk 采用系统默认模式, $N=251988$, $M=100$, $Ncache=2000$, $Nvec=376$\relax }{figure.5.7}{}}
\HyPL@Entry{35<</P(34)>>}
\@writefile{lof}{\contentsline {figure}{\numberline {5.8}{\ignorespaces Omp2Parallel在multi-Xeon Phi上运行时间的严格扩展性$N=251988$, $M=10000$, $Ncache=2000$, $Nvec=192$。图中显示我们的算法 获得了超线性的扩展性能，这种超线性扩展的结果部分是由于我们的算法所基于的蒙特卡洛模拟。首先蒙特卡洛模拟需要大量的计算量来达到收敛性， 是个计算密集型的算法，其次蒙特卡洛各次模拟之间具有相互独立性，给算法上的实现提供了很大的潜在并行性。 同时我们的并行算法让单块Xeon Phi只负责一次蒙特卡洛的循环，这样各个Xeon Phi之间由于蒙特卡洛的独立性从而只有极小部分的通信需求, 这就使算法获得了非常理想的扩展性。}}{34}{figure.5.8}}
\newlabel{fig:scale}{{5.8}{34}{Omp2Parallel在multi-Xeon Phi上运行时间的严格扩展性$N=251988$, $M=10000$, $Ncache=2000$, $Nvec=192$。图中显示我们的算法 获得了超线性的扩展性能，这种超线性扩展的结果部分是由于我们的算法所基于的蒙特卡洛模拟。首先蒙特卡洛模拟需要大量的计算量来达到收敛性， 是个计算密集型的算法，其次蒙特卡洛各次模拟之间具有相互独立性，给算法上的实现提供了很大的潜在并行性。 同时我们的并行算法让单块Xeon Phi只负责一次蒙特卡洛的循环，这样各个Xeon Phi之间由于蒙特卡洛的独立性从而只有极小部分的通信需求, 这就使算法获得了非常理想的扩展性。\relax }{figure.5.8}{}}
\HyPL@Entry{36<</P(35)>>}
\@writefile{lof}{\contentsline {figure}{\numberline {5.9}{\ignorespaces Omp2Parallel在multi-CPU上的收敛性, $N=251988$, $Nvec=192$ 当我们的$M$次数超过$10^4$,我们搜索到得$N$值已经收敛。 而且整个收敛过程中，我们算法的效果随着$M$值的增大也未表现出很大的波动性。}}{35}{figure.5.9}}
\newlabel{fig:converge}{{5.9}{35}{Omp2Parallel在multi-CPU上的收敛性, $N=251988$, $Nvec=192$ 当我们的$M$次数超过$10^4$,我们搜索到得$N$值已经收敛。 而且整个收敛过程中，我们算法的效果随着$M$值的增大也未表现出很大的波动性。\relax }{figure.5.9}{}}
\HyPL@Entry{37<</P(36)>>}
